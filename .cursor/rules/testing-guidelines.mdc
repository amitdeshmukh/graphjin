---
description:
globs:
alwaysApply: false
---
---
description: Comprehensive testing guidelines for GraphJin development
alwaysApply: false
---

# Testing Guidelines

## Testing Philosophy

GraphJin follows a comprehensive testing strategy to ensure reliability, security, and performance:

- **Unit Tests** - Test individual functions and methods in isolation
- **Integration Tests** - Test complete workflows with real databases
- **Benchmark Tests** - Measure and prevent performance regressions
- **Fuzz Tests** - Discover edge cases and security vulnerabilities

## Test Organization

### Directory Structure
```
tests/           # Integration tests with database fixtures
core/*_test.go   # Unit tests alongside source code
benchmark/       # Performance benchmarks
corpus/          # Fuzz test inputs
```

### Test Naming Conventions
- Unit tests: `TestFunctionName`
- Benchmark tests: `BenchmarkFunctionName`
- Fuzz tests: `FuzzFunctionName`
- Integration tests: `TestIntegrationScenario`

## Unit Testing

### Best Practices
- Test one function per test case
- Use table-driven tests for multiple scenarios
- Mock external dependencies
- Test both success and failure paths
- Use meaningful test names that describe the scenario

### Example Structure
```go
func TestQueryCompiler_CompileQuery(t *testing.T) {
    tests := []struct {
        name     string
        query    string
        expected string
        wantErr  bool
    }{
        // test cases
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // test implementation
        })
    }
}
```

## Integration Testing

### Database Setup
- Use Docker containers for consistent environments
- Test against multiple database versions (PostgreSQL, MySQL)
- Include realistic schema scenarios
- Use fixtures for test data

### Test Scenarios
- Full GraphQL to SQL compilation pipeline
- Authentication and authorization flows
- Real-time subscriptions
- Configuration loading and validation
- Migration and seeding operations

### Running Integration Tests
```bash
# Run all tests including integration
make test

# Run tests with specific database
cd tests && go test -db=mysql -tags=mysql

# Run with race detection
go test -race ./...
```

## Benchmark Testing

### Performance Metrics
- Query compilation time
- SQL generation performance
- Memory allocations
- Database query execution time

### Benchmark Structure
```go
func BenchmarkQueryCompiler_Compile(b *testing.B) {
    // setup
    for i := 0; i < b.N; i++ {
        // operation to benchmark
    }
}
```

### Performance Monitoring
- Compare against baseline performance
- Track memory allocations with `-benchmem`
- Use `benchstat` for statistical analysis
- Set performance regression thresholds

## Fuzz Testing

### Security-Critical Components
- GraphQL parser and lexer
- JSON processing utilities
- SQL query generation
- Input validation functions

### Fuzz Test Implementation
```go
func FuzzGraphQLParser(f *testing.F) {
    // seed inputs
    f.Add("query { users { id } }")
    
    f.Fuzz(func(t *testing.T, input string) {
        // test implementation that should not panic
    })
}
```

### Running Fuzz Tests
```bash
# Run fuzz tests
go test -fuzz=FuzzGraphQLParser

# Run with timeout
go test -fuzz=FuzzGraphQLParser -fuzztime=30s
```

## Database Testing

### Multi-Database Support
- Test core functionality across all supported databases
- Handle database-specific features appropriately
- Test migration scripts on different database versions
- Verify schema discovery works correctly

### Test Data Management
- Use transactions for test isolation
- Clean up test data after each test
- Use realistic data volumes for performance tests
- Test with various data types and edge cases

## Continuous Integration

### Test Automation
- Run all tests on every commit
- Include multiple Go versions
- Test against multiple database versions
- Generate coverage reports

### Quality Gates
- Minimum code coverage thresholds
- Performance regression detection
- Security vulnerability scanning
- Linting and code quality checks

## Test Utilities

### Helper Functions
- Database connection setup
- Test data generation
- Assertion helpers
- Mock implementations

### Common Patterns
```go
// Test helper for database setup
func setupTestDB(t *testing.T) *sql.DB {
    // setup code
}

// Test helper for GraphJin instance
func setupGraphJin(t *testing.T, config *Config) *GraphJin {
    // setup code
}
```

## Debugging Tests

### Test Debugging
- Use `t.Log()` for debug output
- Enable verbose mode with `-v`
- Use `t.Skip()` for conditional tests
- Leverage IDE debugging capabilities

### Common Issues
- Database connection problems
- Race conditions in concurrent tests
- Flaky tests due to timing issues
- Test data conflicts

## Performance Testing

### Load Testing
- Test with realistic concurrent load
- Measure response times under load
- Monitor resource usage (CPU, memory)
- Test WebSocket connection limits

### Stress Testing
- Test with high query complexity
- Test with large result sets
- Test memory usage with large schemas
- Test connection pool exhaustion

## Security Testing

### Input Validation
- Test with malicious GraphQL queries
- Test SQL injection attempts
- Test authentication bypass attempts
- Test authorization boundary conditions

### Fuzz Testing Focus Areas
- GraphQL query parsing
- JSON input processing
- Configuration file parsing
- Database query generation
