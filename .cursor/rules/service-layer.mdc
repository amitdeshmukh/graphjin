---
description:
globs:
alwaysApply: false
---
---
description: GraphJin service layer development guidelines
globs: ["serv/**/*.go", "serv/**/*.js", "serv/**/*.json"]
alwaysApply: false
---

# Service Layer Guidelines

## Service Architecture

The GraphJin service (`serv/`) provides a complete HTTP server with:

- **REST API** - Traditional REST endpoints for simple operations
- **GraphQL API** - Full GraphQL query and mutation support
- **WebSocket API** - Real-time subscriptions and live queries
- **Admin API** - Management and monitoring endpoints

## API Design Principles

### REST Endpoints
- Follow RESTful conventions
- Use appropriate HTTP status codes
- Support standard HTTP headers (ETag, Cache-Control, etc.)
- Implement proper error responses with meaningful messages

### GraphQL Endpoints
- Support both GET and POST requests
- Handle query introspection in development mode
- Implement query complexity analysis
- Provide detailed error information with locations

### WebSocket Support
- Use standard WebSocket protocols
- Handle connection lifecycle properly
- Implement heartbeat/keepalive mechanisms
- Support subscription multiplexing

## Security Implementation

### Authentication
- Support multiple auth providers (JWT, Rails, custom)
- Validate tokens on every request
- Extract user context from auth tokens
- Handle token expiration gracefully

### Authorization
- Implement role-based access control
- Check permissions at the GraphQL field level
- Support row-level security policies
- Log authorization failures for monitoring

### Rate Limiting
- Implement per-user and per-IP rate limiting
- Use sliding window algorithms
- Provide clear rate limit headers
- Support different limits for different endpoints

## Configuration Management

### Environment Handling
- Support multiple config files (dev.yml, prod.yml, etc.)
- Allow environment variable overrides
- Validate configuration on startup
- Provide helpful error messages for misconfigurations

### Production vs Development
- Strict security in production mode
- Enhanced debugging in development mode
- Different default settings per environment
- Clear indicators of current mode

## Performance Optimization

### Caching
- Implement HTTP caching with ETags
- Cache compiled GraphQL queries
- Use connection pooling for databases
- Support Redis for distributed caching

### Compression
- Enable gzip/deflate compression
- Compress GraphQL responses
- Handle compression negotiation
- Monitor compression ratios

### Monitoring
- Expose Prometheus metrics
- Support OpenTelemetry tracing
- Log performance metrics
- Track query execution times

## Error Handling

### HTTP Errors
- Use appropriate status codes (400, 401, 403, 404, 500)
- Provide structured error responses
- Include request IDs for tracing
- Log errors with sufficient context

### GraphQL Errors
- Follow GraphQL error specification
- Include error locations and paths
- Provide helpful error messages
- Support error extensions for additional context

## Development Workflow

### Adding New Endpoints
1. Define route handlers with proper middleware
2. Implement authentication and authorization
3. Add input validation and sanitization
4. Include comprehensive error handling
5. Add tests for success and failure cases
6. Document API changes

### WebSocket Features
1. Define message types and protocols
2. Implement connection management
3. Handle subscription lifecycle
4. Add proper error handling
5. Test connection scenarios (connect, disconnect, reconnect)

### Configuration Changes
1. Update configuration structs
2. Add validation logic
3. Update default configurations
4. Document new settings
5. Test with different environments

## Testing Strategy

### Unit Tests
- Test individual handlers and middleware
- Mock external dependencies
- Test error conditions
- Verify security implementations

### Integration Tests
- Test full HTTP request/response cycles
- Test WebSocket connections
- Verify authentication flows
- Test with real database connections

### Load Testing
- Test under concurrent load
- Verify rate limiting behavior
- Monitor memory usage
- Test WebSocket connection limits

## Deployment Considerations

### Docker Support
- Optimize container size
- Use multi-stage builds
- Handle graceful shutdowns
- Support health checks

### Kubernetes Deployment
- Provide readiness and liveness probes
- Support horizontal pod autoscaling
- Handle rolling updates
- Configure resource limits

### Monitoring and Observability
- Export metrics in Prometheus format
- Support distributed tracing
- Implement structured logging
- Provide debug endpoints (in development)
