---
description:
globs:
alwaysApply: false
---
---
description: GraphQL to SQL compiler core development guidelines
globs: ["core/**/*.go", "core/**/*.sql"]
alwaysApply: false
---

# Core Compiler Guidelines

## Compiler Architecture

The GraphJin core follows a three-stage compilation pipeline:

1. **GraphQL Parsing** (`core/internal/graph/`) - Lexical analysis and AST generation
2. **Query Compilation** (`core/internal/qcode/`) - GraphQL AST to intermediate representation
3. **SQL Generation** (`core/internal/psql/`) - Intermediate representation to optimized SQL

## Key Principles

### Performance First
- Generate single SQL queries regardless of GraphQL complexity
- Leverage prepared statements for security and performance
- Optimize for database-specific features when available
- Cache compiled queries and schema metadata

### Security by Design
- All production queries must be pre-compiled and saved
- Use parameterized queries to prevent SQL injection
- Validate all input at the GraphQL layer
- Implement role-based access control at the SQL level

### Database Compatibility
- Primary support: PostgreSQL (full features)
- Secondary support: MySQL 8+ (limited mutations)
- Test against multiple database versions
- Use database-specific optimizations when beneficial

## Code Organization

### Internal Packages
- Keep `internal/` packages truly internal
- Use interfaces for database-specific implementations
- Separate concerns: parsing, compilation, generation
- Maintain clear data flow between stages

### Error Handling
- Use structured errors with context
- Provide helpful error messages for developers
- Log compilation errors with query context
- Fail fast on invalid configurations

### Testing
- Unit tests for individual functions
- Integration tests for full compilation pipeline
- Benchmark tests for performance regression detection
- Fuzz tests for security-critical parsers

## Schema Discovery (`sdata/`)

### Database Introspection
- Auto-discover tables, columns, and relationships
- Cache schema information for performance
- Support custom type mappings
- Handle database-specific features (arrays, JSON, etc.)

### Relationship Detection
- Use foreign keys to build relationship graph
- Support many-to-many through junction tables
- Handle self-referencing relationships
- Allow manual relationship overrides

## Query Compilation (`qcode/`)

### AST Processing
- Validate GraphQL syntax and semantics
- Build query execution plan
- Optimize field selection and joins
- Handle fragments and variables

### Security Validation
- Check field permissions based on roles
- Validate argument types and constraints
- Enforce query complexity limits
- Block dangerous operations in production

## SQL Generation (`psql/`)

### Query Optimization
- Use CTEs for complex nested queries
- Leverage database indexes for joins
- Implement efficient pagination with cursors
- Generate database-specific SQL dialects

### Mutation Handling
- Support insert, update, delete operations
- Handle nested mutations with transactions
- Validate data constraints
- Return meaningful error messages

## Development Workflow

### Adding New Features
1. Start with GraphQL AST changes if needed
2. Update query compilation logic
3. Modify SQL generation
4. Add comprehensive tests
5. Update documentation

### Performance Optimization
- Profile with real-world queries
- Benchmark against previous versions
- Test with large datasets
- Monitor memory usage and allocations

### Database Support
- Test with official database images
- Verify feature compatibility
- Document limitations per database
- Provide migration paths for breaking changes
