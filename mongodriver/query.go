// Package mongodriver provides a database/sql compatible driver for MongoDB.
// It accepts JSON query DSL generated by GraphJin's MongoDB dialect and
// translates it to MongoDB aggregation pipelines.
package mongodriver

import (
	"encoding/json"
	"fmt"
)

// QueryDSL represents the JSON query structure generated by the MongoDB dialect.
// This is the "SQL" that GraphJin generates for MongoDB.
type QueryDSL struct {
	Operation      string           `json:"operation"`
	Collection     string           `json:"collection,omitempty"`
	FieldName      string           `json:"field_name,omitempty"`  // GraphQL field name to wrap result in
	Singular       bool             `json:"singular,omitempty"`    // If true, return single object instead of array
	Pipeline       []map[string]any `json:"pipeline,omitempty"`
	Document       map[string]any   `json:"document,omitempty"`
	Documents      []map[string]any `json:"documents,omitempty"`     // For bulk inserts (insertMany)
	RawDocument    string           `json:"raw_document,omitempty"`  // Raw document placeholder (e.g., "$1")
	ConnectColumn  string           `json:"connect_column,omitempty"` // Array column to populate from connect
	ConnectPath    string           `json:"connect_path,omitempty"`   // Path to connect IDs in document (e.g., "$2")
	FKConnect      *FKConnect       `json:"fk_connect,omitempty"`     // FK column to populate from connect (single value)
	FKConnects     []FKConnect      `json:"fk_connects,omitempty"`    // Multiple FK columns to populate from connects
	FKValues       map[string]any   `json:"fk_values,omitempty"`      // Direct FK values to set on root document
	ReturnPipeline []map[string]any `json:"return_pipeline,omitempty"` // Pipeline to run after insert to fetch return data
	Filter         map[string]any   `json:"filter,omitempty"`
	Update         map[string]any   `json:"update,omitempty"`
	Options        map[string]any   `json:"options,omitempty"`
	Presets        map[string]any   `json:"presets,omitempty"`        // Preset values to merge with document
	Params         []string         `json:"params,omitempty"`
	Queries        []*QueryDSL      `json:"queries,omitempty"`        // For multi_aggregate operations
	Inserts        []NestedInsert   `json:"inserts,omitempty"`        // For nested_insert operations
	RootCollection    string           `json:"root_collection,omitempty"`    // Root collection for nested_insert
	RootMutateID      int              `json:"root_mutate_id,omitempty"`     // ID of root mutation for nested_insert
	AllSameCollection bool             `json:"all_same_collection,omitempty"` // True if all inserts are in same collection (recursive-only)
}

// NestedInsert represents a single insert in a nested mutation operation.
type NestedInsert struct {
	Collection string         `json:"collection"`
	ID         int            `json:"id"`
	ParentID   int            `json:"parent_id"`
	RelType    string         `json:"rel_type,omitempty"`     // "one_to_one" or "one_to_many"
	FKCol      string         `json:"fk_col,omitempty"`       // FK column name (e.g., "owner_id")
	FKOnParent bool           `json:"fk_on_parent,omitempty"` // true if FK is on parent table, false if on child
	IsConnect  bool           `json:"is_connect,omitempty"`   // true if this is a connect (UPDATE) rather than insert
	Document   map[string]any `json:"document"`
}

// FKConnect represents metadata for FK connect operations.
// Used to transform owner.connect.id -> owner_id during document processing.
type FKConnect struct {
	Path   string `json:"path"`   // Field path in document (e.g., "owner")
	Column string `json:"column"` // FK column name (e.g., "owner_id")
}

// Supported operations
const (
	OpAggregate         = "aggregate"
	OpMultiAggregate    = "multi_aggregate"
	OpFind              = "find"
	OpFindOne           = "findOne"
	OpInsertOne         = "insertOne"
	OpInsertMany        = "insertMany"
	OpUpdateOne         = "updateOne"
	OpUpdateMany        = "updateMany"
	OpDeleteOne         = "deleteOne"
	OpDeleteMany        = "deleteMany"
	OpNestedInsert      = "nested_insert"
	OpIntrospectInfo    = "introspect_info"
	OpIntrospectColumns = "introspect_columns"
	OpIntrospectFuncs   = "introspect_functions"
)

// ParseQuery parses a JSON query DSL string into a QueryDSL struct.
func ParseQuery(query string) (*QueryDSL, error) {
	var q QueryDSL
	if err := json.Unmarshal([]byte(query), &q); err != nil {
		return nil, fmt.Errorf("mongodriver: invalid query DSL: %w", err)
	}
	if q.Operation == "" {
		return nil, fmt.Errorf("mongodriver: missing operation in query DSL")
	}
	return &q, nil
}

// SubstituteParams replaces parameter placeholders ($1, $2, etc.) with actual values.
func (q *QueryDSL) SubstituteParams(args []any) error {
	if len(args) == 0 {
		return nil
	}

	// Build param map
	paramMap := make(map[string]any)
	for i, arg := range args {
		paramMap[fmt.Sprintf("$%d", i+1)] = arg
	}

	// Substitute in pipeline
	for i, stage := range q.Pipeline {
		q.Pipeline[i] = substituteInMap(stage, paramMap)
	}

	// Substitute in filter
	if q.Filter != nil {
		q.Filter = substituteInMap(q.Filter, paramMap)
	}

	// Substitute in document
	if q.Document != nil {
		q.Document = substituteInMap(q.Document, paramMap)
	}

	// Substitute in documents array (for inline bulk inserts)
	if len(q.Documents) > 0 {
		for i, doc := range q.Documents {
			q.Documents[i] = substituteInMap(doc, paramMap)
		}
	}

	// Substitute in update
	if q.Update != nil {
		q.Update = substituteInMap(q.Update, paramMap)
	}

	// Substitute in presets
	if q.Presets != nil {
		q.Presets = substituteInMap(q.Presets, paramMap)
	}

	// Handle RawDocument - parse the parameter value as JSON into Document or Documents
	if q.RawDocument != "" {
		if val, ok := paramMap[q.RawDocument]; ok {
			// The value should be a JSON string that we parse into the Document
			var rawStr string
			switch v := val.(type) {
			case string:
				rawStr = v
			case []byte:
				rawStr = string(v)
			case json.RawMessage:
				rawStr = string(v)
			default:
				return fmt.Errorf("mongodriver: raw_document parameter must be string, []byte, or json.RawMessage, got %T", val)
			}

			// Try to parse as array first (for bulk inserts)
			rawBytes := []byte(rawStr)
			if len(rawBytes) > 0 && rawBytes[0] == '[' {
				var docs []map[string]any
				if err := json.Unmarshal(rawBytes, &docs); err != nil {
					return fmt.Errorf("mongodriver: failed to parse raw_document JSON array: %w", err)
				}
				q.Documents = docs
				// Switch operation from insertOne to insertMany for bulk inserts
				if q.Operation == OpInsertOne {
					q.Operation = OpInsertMany
				}
			} else {
				// Parse as single object
				var doc map[string]any
				if err := json.Unmarshal(rawBytes, &doc); err != nil {
					return fmt.Errorf("mongodriver: failed to parse raw_document JSON: %w", err)
				}
				q.Document = doc
			}
		}
	}

	// Handle ConnectPath - extract connect IDs from the document
	if q.ConnectColumn != "" && q.ConnectPath != "" {
		// The ConnectPath points to the parameter with connect IDs
		// But the IDs are actually embedded in the Document under "tablename.connect.id"
		// We need to extract them and add them to the document as the ConnectColumn
		if q.Document != nil {
			extractConnectIDs(q.Document, q.ConnectColumn)
		}
	}

	// Handle FK connect - transform owner.connect.id -> owner_id
	if q.FKConnect != nil && q.Document != nil {
		transformFKConnect(q.Document, q.FKConnect.Path, q.FKConnect.Column)
	}

	// Handle multiple FK connects - transform each path.connect.id -> column
	for _, fkc := range q.FKConnects {
		if q.Document != nil {
			transformFKConnect(q.Document, fkc.Path, fkc.Column)
		}
	}

	return nil
}

// extractConnectIDs looks for "tablename: {connect: {id: [...]}} patterns in the document
// and extracts the IDs into a flat array column
func extractConnectIDs(doc map[string]any, connectColumn string) {
	// Look for nested objects that have "connect" with "id" array
	for key, val := range doc {
		if nestedObj, ok := val.(map[string]any); ok {
			if connectObj, hasConnect := nestedObj["connect"].(map[string]any); hasConnect {
				if ids, hasIDs := connectObj["id"]; hasIDs {
					// Found a connect pattern - move the IDs to the connectColumn
					doc[connectColumn] = ids
					// Remove the original nested object
					delete(doc, key)
					return
				}
			}
		}
	}
}

// transformFKConnect transforms FK connect patterns in the document.
// Converts owner: {connect: {id: 6}} -> owner_id: 6
func transformFKConnect(doc map[string]any, path, column string) {
	nested, ok := doc[path].(map[string]any)
	if !ok {
		return
	}
	connect, ok := nested["connect"].(map[string]any)
	if !ok {
		return
	}
	id, ok := connect["id"]
	if !ok {
		return
	}
	// Set the FK column to the connect ID
	doc[column] = id
	// Remove the original nested object
	delete(doc, path)
}

// substituteInMap recursively replaces parameter placeholders in a map.
func substituteInMap(m map[string]any, params map[string]any) map[string]any {
	result := make(map[string]any)
	for k, v := range m {
		result[k] = substituteValue(v, params)
	}
	return result
}

// substituteValue recursively replaces parameter placeholders in a value.
func substituteValue(v any, params map[string]any) any {
	switch val := v.(type) {
	case string:
		if replacement, ok := params[val]; ok {
			// If replacement is json.RawMessage ([]byte), parse it into Go types
			return parseJSONValue(replacement)
		}
		return val
	case map[string]any:
		return substituteInMap(val, params)
	case []any:
		result := make([]any, len(val))
		for i, item := range val {
			result[i] = substituteValue(item, params)
		}
		return result
	default:
		return v
	}
}

// parseJSONValue converts json.RawMessage or []byte into proper Go types.
// This is needed because json.RawMessage is just []byte, which MongoDB
// doesn't understand as JSON - it needs actual Go slices/maps.
func parseJSONValue(v any) any {
	switch val := v.(type) {
	case json.RawMessage:
		var parsed any
		if err := json.Unmarshal(val, &parsed); err != nil {
			return val // Return as-is if parsing fails
		}
		return parsed
	case []byte:
		var parsed any
		if err := json.Unmarshal(val, &parsed); err != nil {
			return val // Return as-is if parsing fails
		}
		return parsed
	default:
		return v
	}
}
